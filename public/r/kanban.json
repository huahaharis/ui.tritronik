{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "kanban",
  "dependencies": [
    "@dnd-kit/core",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities"
  ],
  "registryDependencies": [
    "utils"
  ],
  "files": [
    {
      "path": "src/components/ui/kanban.tsx",
      "content": "import React, { useMemo } from \"react\";\r\nimport {\r\n  DndContext,\r\n  DragOverlay,\r\n  KeyboardSensor,\r\n  MouseSensor,\r\n  TouchSensor,\r\n  useSensor,\r\n  useSensors,\r\n  type DragEndEvent,\r\n  type DragStartEvent,\r\n  type DragOverEvent,\r\n  closestCorners,\r\n  DndContextProps,\r\n} from \"@dnd-kit/core\";\r\nimport {\r\n  SortableContext,\r\n  arrayMove,\r\n  horizontalListSortingStrategy,\r\n  verticalListSortingStrategy,\r\n  rectSortingStrategy,\r\n  useSortable,\r\n} from \"@dnd-kit/sortable\";\r\n\r\nexport {\r\n  horizontalListSortingStrategy,\r\n  verticalListSortingStrategy,\r\n  rectSortingStrategy,\r\n};\r\nimport { CSS } from \"@dnd-kit/utilities\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nexport interface KanbanBoardProps extends DndContextProps {\r\n  children: React.ReactNode;\r\n  className?: string;\r\n}\r\n\r\nexport function KanbanBoard({\r\n  children,\r\n  className,\r\n  ...props\r\n}: KanbanBoardProps) {\r\n  const [isMounted, setIsMounted] = React.useState(false);\r\n\r\n  React.useEffect(() => {\r\n    setIsMounted(true);\r\n  }, []);\r\n\r\n  const sensors = useSensors(\r\n    useSensor(MouseSensor, {\r\n      activationConstraint: {\r\n        distance: 10,\r\n      },\r\n    }),\r\n    useSensor(TouchSensor, {\r\n      activationConstraint: {\r\n        delay: 250,\r\n        tolerance: 5,\r\n      },\r\n    }),\r\n    useSensor(KeyboardSensor),\r\n  );\r\n\r\n  if (!isMounted) return null;\r\n\r\n  return (\r\n    <DndContext\r\n      sensors={sensors}\r\n      collisionDetection={closestCorners}\r\n      {...props}\r\n    >\r\n      <div\r\n        className={cn(\r\n          \"flex h-full w-full gap-4 overflow-x-auto p-4\",\r\n          className,\r\n        )}\r\n      >\r\n        {children}\r\n      </div>\r\n    </DndContext>\r\n  );\r\n}\r\n\r\nexport interface KanbanListProps {\r\n  children: React.ReactNode;\r\n  items: string[];\r\n  className?: string;\r\n  strategy?:\r\n    | typeof horizontalListSortingStrategy\r\n    | typeof verticalListSortingStrategy\r\n    | typeof rectSortingStrategy;\r\n}\r\n\r\nexport function KanbanList({\r\n  children,\r\n  items,\r\n  className,\r\n  strategy = horizontalListSortingStrategy,\r\n}: KanbanListProps) {\r\n  const memoizedItems = useMemo(() => items, [items]);\r\n\r\n  return (\r\n    <SortableContext items={memoizedItems} strategy={strategy}>\r\n      <div className={cn(\"flex gap-4\", className)}>{children}</div>\r\n    </SortableContext>\r\n  );\r\n}\r\n\r\ninterface KanbanCardProps {\r\n  id: string;\r\n  children: React.ReactNode;\r\n  className?: string;\r\n}\r\n\r\nexport function KanbanCard({ id, children, className }: KanbanCardProps) {\r\n  const {\r\n    attributes,\r\n    listeners,\r\n    setNodeRef,\r\n    transform,\r\n    transition,\r\n    isDragging,\r\n  } = useSortable({ id });\r\n\r\n  const style = {\r\n    transform: CSS.Transform.toString(transform),\r\n    transition,\r\n    opacity: isDragging ? 0.5 : 1,\r\n  };\r\n\r\n  return (\r\n    <div\r\n      ref={setNodeRef}\r\n      style={style}\r\n      {...attributes}\r\n      {...listeners}\r\n      className={cn(\"cursor-grab active:cursor-grabbing\", className)}\r\n    >\r\n      {children}\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface KanbanColumnProps {\r\n  id: string;\r\n  children: React.ReactNode;\r\n  className?: string;\r\n}\r\n\r\nexport function KanbanColumn({ id, children, className }: KanbanColumnProps) {\r\n  const { setNodeRef } = useSortable({ id });\r\n\r\n  return (\r\n    <div\r\n      ref={setNodeRef}\r\n      className={cn(\r\n        \"flex h-full min-w-[350px] flex-col gap-4 rounded-md bg-muted/50 p-4\",\r\n        className,\r\n      )}\r\n    >\r\n      {children}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport function KanbanDragOverlay({ children }: { children: React.ReactNode }) {\r\n  return <DragOverlay>{children}</DragOverlay>;\r\n}\r\n\r\nexport type UniqueIdentifier = string | number;\r\n\r\nexport interface BaseTask {\r\n  id: UniqueIdentifier;\r\n}\r\n\r\nexport interface BaseColumn<T extends BaseTask> {\r\n  id: UniqueIdentifier;\r\n  title: string;\r\n  tasks: T[];\r\n}\r\n\r\nexport function useKanban<T extends BaseTask, C extends BaseColumn<T>>(\r\n  initialColumns: C[],\r\n  onDragEnd?: (columns: C[]) => void,\r\n) {\r\n  const [columns, setColumns] = React.useState<C[]>(initialColumns);\r\n  const [activeTask, setActiveTask] = React.useState<T | null>(null);\r\n  const [activeColumn, setActiveColumn] = React.useState<C | null>(null);\r\n\r\n  const sensors = useSensors(\r\n    useSensor(MouseSensor, {\r\n      activationConstraint: {\r\n        distance: 10,\r\n      },\r\n    }),\r\n    useSensor(TouchSensor, {\r\n      activationConstraint: {\r\n        delay: 250,\r\n        tolerance: 5,\r\n      },\r\n    }),\r\n    useSensor(KeyboardSensor, {\r\n      coordinateGetter: (\r\n        event,\r\n        {\r\n          context: {\r\n            active,\r\n            over,\r\n            collisionRect,\r\n            droppableRects,\r\n            droppableContainers,\r\n          },\r\n        },\r\n      ) => {\r\n        return { x: 0, y: 0 };\r\n      },\r\n    }),\r\n  );\r\n\r\n  const findColumn = React.useCallback(\r\n    (id: UniqueIdentifier) => {\r\n      return columns.find((col) => col.id === id);\r\n    },\r\n    [columns],\r\n  );\r\n\r\n  const handleDragStart = React.useCallback(\r\n    (event: DragStartEvent) => {\r\n      const { active } = event;\r\n      const activeId = active.id;\r\n\r\n      const col = findColumn(activeId);\r\n      if (col) {\r\n        setActiveColumn(col);\r\n        return;\r\n      }\r\n\r\n      const task = columns\r\n        .flatMap((c) => c.tasks)\r\n        .find((t) => t.id === activeId);\r\n      if (task) setActiveTask(task);\r\n    },\r\n    [columns, findColumn],\r\n  );\r\n\r\n  const handleDragOver = React.useCallback(\r\n    (event: DragOverEvent) => {\r\n      const { active, over } = event;\r\n      if (!over) return;\r\n\r\n      const activeId = active.id;\r\n      const overId = over.id;\r\n\r\n      const activeColumnId = columns.find((col) =>\r\n        col.tasks.some((t) => t.id === activeId),\r\n      )?.id;\r\n      const overColumnId = columns.find(\r\n        (col) => col.id === overId || col.tasks.some((t) => t.id === overId),\r\n      )?.id;\r\n\r\n      if (!activeColumnId || !overColumnId || activeColumnId === overColumnId)\r\n        return;\r\n\r\n      setColumns((prev) => {\r\n        const activeColIndex = prev.findIndex(\r\n          (col) => col.id === activeColumnId,\r\n        );\r\n        const overColIndex = prev.findIndex((col) => col.id === overColumnId);\r\n\r\n        const activeCol = prev[activeColIndex];\r\n        const overCol = prev[overColIndex];\r\n\r\n        const activeTaskIndex = activeCol.tasks.findIndex(\r\n          (t) => t.id === activeId,\r\n        );\r\n        const overTaskIndex = overCol.tasks.findIndex((t) => t.id === overId);\r\n\r\n        let newIndex: number;\r\n        if (overTaskIndex >= 0) {\r\n          newIndex = overTaskIndex;\r\n        } else {\r\n          newIndex = overCol.tasks.length + 1;\r\n        }\r\n\r\n        const newActiveCol = {\r\n          ...activeCol,\r\n          tasks: [\r\n            ...activeCol.tasks.slice(0, activeTaskIndex),\r\n            ...activeCol.tasks.slice(activeTaskIndex + 1),\r\n          ],\r\n        } as C;\r\n\r\n        const newOverCol = {\r\n          ...overCol,\r\n          tasks: [\r\n            ...overCol.tasks.slice(0, newIndex),\r\n            activeCol.tasks[activeTaskIndex],\r\n            ...overCol.tasks.slice(newIndex),\r\n          ],\r\n        } as C;\r\n\r\n        const newCols = [...prev];\r\n        newCols[activeColIndex] = newActiveCol;\r\n        newCols[overColIndex] = newOverCol;\r\n\r\n        return newCols;\r\n      });\r\n    },\r\n    [columns],\r\n  );\r\n\r\n  const handleDragEnd = React.useCallback(\r\n    (event: DragEndEvent) => {\r\n      const { active, over } = event;\r\n      setActiveColumn(null);\r\n      setActiveTask(null);\r\n\r\n      if (!over) return;\r\n\r\n      const activeId = active.id;\r\n      const overId = over.id;\r\n\r\n      if (activeId === overId) return;\r\n\r\n      const activeColumnIndex = columns.findIndex((col) => col.id === activeId);\r\n      if (activeColumnIndex !== -1) {\r\n        const overColumnIndex = columns.findIndex((col) => col.id === overId);\r\n        if (overColumnIndex !== -1) {\r\n          const newCols = arrayMove(\r\n            columns,\r\n            activeColumnIndex,\r\n            overColumnIndex,\r\n          );\r\n          setColumns(newCols);\r\n          if (onDragEnd) onDragEnd(newCols);\r\n        }\r\n        return;\r\n      }\r\n\r\n      const activeColId = columns.find((col) =>\r\n        col.tasks.some((t) => t.id === activeId),\r\n      )?.id;\r\n      const overColId = columns.find((col) =>\r\n        col.tasks.some((t) => t.id === overId),\r\n      )?.id;\r\n\r\n      if (columns.find((c) => c.id === overId)) {\r\n        if (onDragEnd) onDragEnd(columns);\r\n        return;\r\n      }\r\n\r\n      if (activeColId && overColId && activeColId === overColId) {\r\n        const columnIndex = columns.findIndex((col) => col.id === activeColId);\r\n        const column = columns[columnIndex];\r\n\r\n        const oldIndex = column.tasks.findIndex((t) => t.id === activeId);\r\n        const newIndex = column.tasks.findIndex((t) => t.id === overId);\r\n\r\n        const newTasks = arrayMove(column.tasks, oldIndex, newIndex);\r\n\r\n        const newColumns = [...columns];\r\n        newColumns[columnIndex] = { ...column, tasks: newTasks as T[] };\r\n        setColumns(newColumns);\r\n        if (onDragEnd) onDragEnd(newColumns);\r\n      }\r\n      // If different columns, modifying the column structure has already happened in dragOver\r\n      // But we might want to stabilize/save the final state here if we were using a different strategy\r\n      // Since we update state in DragOver for cross-column items,\r\n      // the final state is effectively \"what is currently in columns\" plus the fact that the drag ended.\r\n      // However, since DragOver updates state optimistically, the `columns` variable inside this callback\r\n      // might be stale if we don't include it in dependency array.\r\n      // But we do include it.\r\n      // For cross-column: dragOver handles the move.\r\n      // IF we want to persist cross-column moves, we need to trigger it here too.\r\n      // BUT, dragOver updates state continuously.\r\n      else {\r\n        // For cross-column drag, the state is updated in handleDragOver.\r\n        // We just need to notify the parent of the final state.\r\n        if (onDragEnd) onDragEnd(columns);\r\n      }\r\n    },\r\n    [columns, onDragEnd],\r\n  );\r\n\r\n  return {\r\n    columns,\r\n    setColumns,\r\n    activeTask,\r\n    activeColumn,\r\n    handleDragStart,\r\n    handleDragOver,\r\n    handleDragEnd,\r\n    sensors,\r\n  };\r\n}\r\n",
      "type": "registry:ui"
    }
  ],
  "type": "registry:ui"
}